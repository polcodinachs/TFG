#pragma config(Sensor, S1,     TIR,            sensorI2CCustom)
#pragma config(Sensor, S2,     Touch1,         sensorEV3_Touch)
#pragma config(Sensor, S3,     Touch2,         sensorEV3_Touch)
#pragma config(Sensor, S4,     Touch3,         sensorEV3_Touch)
#pragma config(Motor,  motorA,          MotorA,        tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          MotorB,        tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorC,          MotorC,        tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#include <KioskLibraries/VexIQ/ArmBot_Kiosk.c>

#include "cercle.h"
#include "figures.h"

#define ARDUINO_PORT S1
#define ARDUINO_ADRESS 0x08

byte mensajeI2C[22];
char respuestaI2C[20];
char lectura[10];

int battery;

float encoder[4];
char velocitat[4];
int sensor[4];

int msg_i2c(byte dir_arduino, int tam_mensaje, int tam_respuesta, ubyte byte0, ubyte byte1, long byte2, ubyte byte3, ubyte byte4)
{
	memset(respuestaI2C, 0, sizeof(respuestaI2C));
	tam_mensaje = tam_mensaje + 3;
	mensajeI2C[0] = tam_mensaje;
	mensajeI2C[1] = dir_arduino;

	mensajeI2C[2] = byte0;
	mensajeI2C[3] = byte1;
	mensajeI2C[4] = byte2;
	mensajeI2C[5] = byte3;
	mensajeI2C[6] = byte4;

	sendI2CMsg(S1, &mensajeI2C[0], tam_respuesta);
	wait1Msec(20);

	readI2CReply(ARDUINO_PORT, &respuestaI2C[0], tam_respuesta);

	int x = respuestaI2C[0];

	wait1Msec(35);
	return x;
}


//MANDAR DATOS EV3 -----I2C-----> ARDUINO
void mandar_datos(int motor, byte direccion, int dato1, long dato2, int dato3, char dato4)
{
	msg_i2c(direccion, 5, 5, motor, dato1, dato2, dato3, dato4);
}


// POSICIO INICIAL MOTOR A
void posicioInicialA(){
	if(SensorValue[S2] == 1) { //Estem en la posicio
		respuestaI2C[0] = '4';
		stopMotor(motorA);
	} else if (SensorValue[S2] == 0) { //No estem en la posicio incial
		while(SensorValue[S2] == 0) {
			setMotor(motorA, -10);
			if(SensorValue[S2] == 1){
				stopMotor(motorA);
				encoder[1] = 0;
			}
		}
	}
}

// POSICIO INICIAL MOTOR B
void posicioInicialB(){
	if(SensorValue[S3] == 1) { //Estem en la posicio
		respuestaI2C[1] = '4';
		stopMotor(motorB);
	} else if (SensorValue[S3] == 0) { //No estem en la posicio incial
		while(SensorValue[S3] == 0) {
			setMotor(motorB, -10);
			if(SensorValue[S3] == 1){
				stopMotor(motorB);
				encoder[2] = 0;
			}
		}
	}
}

void straightX(){
	moveMotorTarget(motorA, X, Y);
	waitUntilMotorStop(motorA);
	wait1Msec(100);
}
void straightY(){
	moveMotorTarget(motorB, X, Y);
	waitUntilMotorStop(motorB);
	wait1Msec(100);
}
void diagonal(){
	moveMotorTarget(motorA, )
}

task main()
{
	while(true)
	{
	//DECLARACIONS VELOCITATS
	velocitat[1] = motor[motorA];
	velocitat[2] = motor[motorB];
	velocitat[3] = motor[motorC];

	//DECLARACIONS SENSORS
	sensor[1] = SensorValue[S2];
	sensor[2] = SensorValue[S3];
	sensor[3] = SensorValue[S4];

	//DECLARACIONS ENCODERS
	encoder[1] = getMotorEncoder(motorA);
	encoder[2] = getMotorEncoder(motorB);
	encoder[3] = getMotorEncoder(motorC);

		//REBRE DADES EV3 <----I2C---- ARDUINO
		for(int i = 0; i <= 5; i++){
			lectura[i] = respuestaI2C[i];
		}

		//ENVIAR DADES A ARDUINO MOTOR A
		for(int i = 1; i <= 3; i ++){
			mandar_datos(i, ARDUINO_ADRESS, sensor[i], encoder[i], velocitat[i], battery);
		}

			//LECTURA DE LA POSICIO DEL MOTOR A
		if(SensorValue[S2] == 1){
			resetMotorEncoder(motorA);
		} else if(SensorValue[S2] == 0){
			encoder[1] = getMotorEncoder(motorA);
		}

			//LECTURA DE LA POSICIO DEL MOTOR B
		if(SensorValue[S3] == 1){
			resetMotorEncoder(motorB);
		} else if(SensorValue[S3] == 0){
			encoder[2] = getMotorEncoder(motorB);
		}


		if(respuestaI2C[0] == 1){ //MOVIMENTS MANUALS
			if(respuestaI2C[1] == 1){ //MOTOR A
			switch(respuestaI2C[2]){
			case 1:
				posicioInicialA();
				break;
			case 2:
					motor[motorA] = respuestaI2C[3];
					break;
			case 3:
				motor[motorA] = -respuestaI2C[3];
				break;
			case 4:
				stopMotor(motorA);
				break;
			}
		} else if(respuestaI2C[1] == 2){ //MOTOR B
			switch(respuestaI2C[2]){
			case 1:
				posicioInicialB();
				break;
			case 2:
					motor[motorB] = respuestaI2C[3];
					break;
			case 3:
				motor[motorB] = -respuestaI2C[3];
				break;
			case 4:
				stopMotor(motorB);
				break;
			}
		} else if(respuestaI2C[1] == 3) {
			switch(respuestaI2C[2]){
			case 1:
				//posicioInicialC();
				break;
			case 2:
					motor[motorC] = respuestaI2C[3];
					break;
			case 3:
				motor[motorC] = -respuestaI2C[3];
				break;
			case 4:
				stopMotor(motorC);
				break;
			}
		}
	} else if (respuestaI2C[0] == 2) { //DISSENY DE FIGURES
		switch (respuestaI2C[1]) {
			case 10:
				quadrat();
				break;
			case 11:
				triangle();
				break;
			case 12:
				pentagon();
				break;
			case 13:
				hexagon();
				break;
			case 14:
				heptagon();
				break;
			case 15:
				lletraA();
				break;
			case 17:
				lletraC();
				break;
			case 18:
				lletraF();
				break;
			case 19:
				lletraH();
				break;
			case 20:
				lletraI();
				break;
			case 21:
				lletraK();
				break;
			case 22:
				lletraL();
				break;
			case 23:
				lletraM();
				break;
			case 24:
				break;
		}
	}

		//SEGURETAT MOTOR A
		if(encoder[1] >= 7400){
			resetMotorEncoder(motorA);
			stopMotor(motorA);
		} else if(motor[motorA] < 0) {
			if(SensorValue[S2] == 1){
				stopMotor(motorA);
			}
		}

		//SEGURETAT MOTOR C
		if(encoder[3]*-1 >= 7800){
			resetMotorEncoder(motorC);
			stopMotor(motorC);
		} else if(motor[motorC] < 0) {
			if(SensorValue[S4] == 1){
				stopMotor(motorC);
			}
		}

		//SEGURETAT MOTOR B
		if(encoder[2]*-1 >= 7800){
			resetMotorEncoder(motorB);
			stopMotor(motorB);
		} else if(motor[motorB] < 0) {
			if(SensorValue[S3] == 1){
				stopMotor(motorB);
			}
		}
		wait1Msec(100);
	}
}
